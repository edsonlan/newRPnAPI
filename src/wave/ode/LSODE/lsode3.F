#
      subroutine rscom (rsav, isav)
c-----------------------------------------------------------------------
c this routine restores from rsav and isav the contents of common
c blocks ls0001 and eh0001, which are used internally in the lsode
c package.  this presumes that rsav and isav were loaded by means
c of subroutine svcom or the equivalent.
c-----------------------------------------------------------------------
      integer isav(*)
      integer ieh, ils
      integer i, lenils, lenrls
      double precision rsav(*),   rls
cold  dimension rsav(1), isav(1)
      common /ls0001/ rls(219), ils(39)
      common /eh0001/ ieh(2)
      data lenrls/219/, lenils/39/
c
      do 10 i = 1,lenrls
 10     rls(i) = rsav(i)
      do 20 i = 1,lenils
 20     ils(i) = isav(i)
      ieh(1) = isav(lenils+1)
      ieh(2) = isav(lenils+2)
      return
c----------------------- end of subroutine rscom -----------------------
      end
      subroutine xerrwv (msg, nmes, nerr, iert, ni, i1, i2, nr, r1, r2)
      integer msg, nmes, nerr, iert, ni, i1, i2, nr,
     1   i, lun, lunit, mesflg, ncpw, nch, nwds
      double precision r1, r2
      dimension msg(nmes)
c-----------------------------------------------------------------------
c subroutines xerrwv, xsetf, and xsetun, as given here, constitute
c a simplified version of the slatec error handling package.
c written by a. c. hindmarsh at llnl.  version of august 13, 1981.
c
c all arguments are input arguments.
c
c msg    = the message (hollerith litteral or integer array).
c nmes   = the length of msg (number of characters).
c nerr   = the error number (not used).
c iert   = the error type..
c  1 means recoverable (control returns to caller).
c  2 means fatal (run is aborted--see note below).
c ni     = number of integers (0, 1, or 2) to be printed with message.
c i1,i2  = integers to be printed, depending on ni.
c nr     = number of double precisions (0, 1, or 2) to be printed with message.
c r1,r2  = double precisions to be printed, depending on nr.
c
c note..  this routine is machine-dependent and specialized for use
c in limited context, in the following ways..
c 1. the number of hollerith characters stored per word, denoted
cby ncpw below, is a data-loaded constant.
c 2. the value of nmes is assumed to be at most 60.
c(multi-line messages are generated by repeated calls.)
c 3. if iert = 2, control passes to the statement   stop
cto abort the run.  this statement may be machine-dependent.
c 4. r1 and r2 are assumed to be in single precision and are printed
cin e21.13 format.
c 5. the common block /eh0001/ below is data-loaded (a machine-
cdependent feature) with default values.
cthis block is needed for proper retention of parameters used by
cthis routine which the user can reset by calling xsetf or xsetun.
cthe variables in this block are as follows..
c   mesflg = print control flag..
c1 means print all messages (the default).
c0 means no printing.
c   lunit  = logical unit number for messages.
cthe default is 6 (machine-dependent).
c-----------------------------------------------------------------------
c the following are instructions for installing this routine
c in different machine environments.
c
c to change the default output unit, change the data statement below.
c
c for some systems, the data statement below must be replaced
c by a separate block data subprogram.
c
c for a different number of characters per word, change the
c data statement setting ncpw below, and format 10.  alternatives for
c various computers are shown in comment cards.
c
c for a different run-abort command, change the statement following
c statement 100 at the end.
c-----------------------------------------------------------------------
      common /eh0001/ mesflg, lunit
c
c     foram retiradas linhas acima e colocadas em iniode por arthur em
c     01/03/88
c
c-----------------------------------------------------------------------
c the following data-loaded value of ncpw is valid for the cdc-6600
c and cdc-7600 computers.
c data ncpw/10/
c the following is valid for the cray-1 computer.
c data ncpw/8/
c the following is valid for the burroughs 6700 and 7800 computers.
c data ncpw/6/
c the following is valid for the pdp-10 computer.
c data ncpw/5/
c the following is valid for the vax computer with 4 bytes per integer,
c and for the ibm-360, ibm-370, ibm-303x, and ibm-43xx computers.
c data ncpw/4/
c the following is valid for the pdp-11, or vax with 2-byte integers.
c data ncpw/2/
ccc#ifdef cdc
ccc      data ncpw/10/
ccc#else
      data ncpw/4/
ccc#endif
c
c     foram alteradas as "data" acima por arthur em 07/01/88
c

c-----------------------------------------------------------------------
c
      if (mesflg .eq. 0) go to 100
c get logical unit number. ---------------------------------------------
      lun = lunit
c get number of words in message. --------------------------------------
      nch = min0(nmes,60)
      nwds = nch/ncpw
      if (nch .ne. nwds*ncpw) nwds = nwds + 1
c write the message. ---------------------------------------------------
      write (lun, 10) (msg(i),i=1,nwds)
c-----------------------------------------------------------------------
c the following format statement is to have the form
c 10  format(1x,mmann)
c where nn = ncpw and mm is the smallest integer .ge. 60/ncpw.
c the following is valid for ncpw = 10.
c 10  format(1x,6a10)
c the following is valid for ncpw = 8.
c 10  format(1x,8a8)
c the following is valid for ncpw = 6.
c 10  format(1x,10a6)
c the following is valid for ncpw = 5.
c 10  format(1x,12a5)
c the following is valid for ncpw = 4.
c 10  format(1x,15a4)
ccc#ifdef cdc
ccc  10  format(1x,6a10)
ccc#else
  10  format(1x,15a4)
ccc#endif
c the following is valid for ncpw = 2.
c 10  format(1x,30a2)
c-----------------------------------------------------------------------
      if (ni .eq. 1) write (lun, 20) i1
 20   format(6x,23hin above message,  i1 =,i10)
      if (ni .eq. 2) write (lun, 30) i1,i2
 30   format(6x,23hin above message,  i1 =,i10,3x,4hi2 =,i10)
      if (nr .eq. 1) write (lun, 40) r1
 40   format(6x,23hin above message,  r1 =,d21.13)
      if (nr .eq. 2) write (lun, 50) r1,r2
 50   format(6x,15hin above,  r1 =,d21.13,3x,4hr2 =,d21.13)
c abort the run if iert = 2. -------------------------------------------
 100  if (iert .ne. 2) return
      stop
c----------------------- end of subroutine xerrwv ----------------------
      end
c-----------------------------------------------------------------------
      subroutine iniode

c     this routine must be called once before using the package

      integer mesflg,lunit

      common /eh0001/ mesflg, lunit
c
      integer msfl, luni
      data msfl/1/, luni/6/
      mesflg = msfl
      lunit = luni
c
c     foram alteradas as 4 linhas acima por arthur em 07/01/88
c
c-----------------------------------------------------------------------
      return
      end
      subroutine xsetun (lun)
c
c this routine resets the logical unit number for messages.
c
      integer lun, mesflg, lunit
      common /eh0001/ mesflg, lunit
c
      if (lun .ge. 0) lunit = lun
c
c .gt. substituido por .ge. acima por arthur em 08/03/88
c
      return
c----------------------- end of subroutine xsetun ----------------------
      end
      subroutine xsetf (mflag)
c
c this routine resets the print control flag mflag.
c
      integer mflag, mesflg, lunit
      common /eh0001/ mesflg, lunit
c
      if (mflag .eq. 0 .or. mflag .eq. 1) mesflg = mflag
      return
c----------------------- end of subroutine xsetf -----------------------
      end
      double precision function vnorm (n, v, w)
clll. optimize
c-----------------------------------------------------------------------
c this function routine computes the weighted root-mean-square norm
c of the vector of length n contained in the array v, with weights
c contained in the array w of length n..
c   vnorm = sqrt( (1/n) * sum( v(i)*w(i) )**2 )
c-----------------------------------------------------------------------
      integer n,   i
      double precision v, w,   sum
      dimension v(*), w(*)
      sum = 0.0d0
      do 10 i = 1,n
 10     sum = sum + (v(i)*w(i))**2
      vnorm = sqrt(sum/float(n))
      return
c----------------------- end of function vnorm -------------------------
      end
      double precision function r1mchn (idum)
      integer idum
c-----------------------------------------------------------------------
c this routine computes the unit roundoff of the machine.
c this is defined as the smallest positive machine number
c u such that  1.0 + u .ne. 1.0
c this routine used to be called r1mach. It was changed to r1mchn by 
c Brad and Dan in June 90 to avoid collisions with NCAR.
c-----------------------------------------------------------------------
      double precision u, comp
      u = 1.0d0
 10   u = u*0.5d0
      comp = 1.0d0 + u
      if (comp .ne. 1.0d0) go to 10
      r1mchn = u*2.0d0
      return
c----------------------- end of function r1mchn ------------------------
      end
      subroutine sgefa(a,lda,n,ipvt,info)
clll. optimize
      integer lda,n,ipvt(n),info
      double precision a(lda,n)
c
c sgefa factors a double precision matrix by gaussian elimination.
c
c sgefa is usually called by sgeco, but it can be called
c directly with a saving in time if  rcond  is not needed.
c (time for sgeco) = (1 + 9/n)*(time for sgefa) .
c
c on entry
c
ca       double precision(lda, n)
cthe matrix to be factored.
c
clda     integer
cthe leading dimension of the array  a .
c
cn       integer
cthe order of the matrix  a .
c
c on return
c
ca       an upper triangular matrix and the multipliers
cwhich were used to obtain it.
cthe factorization can be written  a = l*u  where
cl  is a product of permutation and unit lower
ctriangular matrices and  u  is upper triangular.
c
cipvt    integer(n)
can integer vector of pivot indices.
c
cinfo    integer
c= 0  normal value.
c= k  if  u(k,k) .eq. 0.0 .  this is not an error
c condition for this subroutine, but it does
c indicate that sgesl or sgedi will divide by zero
c if called.  use  rcond  in sgeco for a reliable
c indication of singularity.
c
c linpack. this version dated 07/14/77 .
c cleve moler, university of new mexico, argonne national labs.
c
c subroutines and functions
c
c blas saxpy,sscal,isamax
c
c internal variables
c
      double precision t
      integer isamax,j,k,kp1,l,nm1
c
c
c gaussian elimination with partial pivoting
c
      info = 0
      nm1 = n - 1
      if (nm1 .lt. 1) go to 70
      do 60 k = 1, nm1
         kp1 = k + 1
c
cfind l = pivot index
c
         l = isamax(n-k+1,a(k,k),1) + k - 1
         ipvt(k) = l
c
czero pivot implies this column already triangularized
c
         if (a(l,k) .eq. 0.0d0) go to 40
c
c   interchange if necessary
c
            if (l .eq. k) go to 10
               t = a(l,k)
               a(l,k) = a(k,k)
               a(k,k) = t
   10       continue
c
c   compute multipliers
c
            t = -1.0d0/a(k,k)
            call sscal(n-k,t,a(k+1,k),1)
c
c   row elimination with column indexing
c
            do 30 j = kp1, n
               t = a(l,j)
               if (l .eq. k) go to 20
                  a(l,j) = a(k,j)
                  a(k,j) = t
   20          continue
               call saxpy(n-k,t,a(k+1,k),1,a(k+1,j),1)
   30       continue
         go to 50
   40    continue
            info = k
   50    continue
   60 continue
   70 continue
      ipvt(n) = n
      if (a(n,n) .eq. 0.0d0) info = n
      return
      end
      subroutine sgesl(a,lda,n,ipvt,b,job)
clll. optimize
      integer lda,n,ipvt(n),job
      double precision a(lda,n),b(n)
c
c sgesl solves the double precision system
c a * x = b  or  trans(a) * x = b
c using the factors computed by sgeco or sgefa.
c
c on entry
c
ca       double precision(lda, n)
cthe output from sgeco or sgefa.
c
clda     integer
cthe leading dimension of the array  a .
c
cn       integer
cthe order of the matrix  a .
c
cipvt    integer(n)
cthe pivot vector from sgeco or sgefa.
c
cb       double precision(n)
cthe right hand side vector.
c
cjob     integer
c= 0         to solve  a*x = b ,
c= nonzero   to solve  trans(a)*x = b  where
ctrans(a)  is the transpose.
c
c on return
c
cb       the solution vector  x .
c
c error condition
c
ca division by zero will occur if the input factor contains a
czero on the diagonal.  technically this indicates singularity
cbut it is often caused by improper arguments or improper
csetting of lda .  it will not occur if the subroutines are
ccalled correctly and if sgeco has set rcond .gt. 0.0
cor sgefa has set info .eq. 0 .
c
c to compute  inverse(a) * c  where  c  is a matrix
c with  p  columns
c   call sgeco(a,lda,n,ipvt,rcond,z)
c   if (rcond is too small) go to ...
c   do 10 j = 1, p
c  call sgesl(a,lda,n,ipvt,c(1,j),0)
c10 continue
c
c linpack. this version dated 07/14/77 .
c cleve moler, university of new mexico, argonne national labs.
c
c subroutines and functions
c
c blas saxpy,sdot
c
c internal variables
c
      double precision sdot,t
      integer k,kb,l,nm1
c
      nm1 = n - 1
      if (job .ne. 0) go to 50
c
cjob = 0 , solve  a * x = b
cfirst solve  l*y = b
c
         if (nm1 .lt. 1) go to 30
         do 20 k = 1, nm1
            l = ipvt(k)
            t = b(l)
            if (l .eq. k) go to 10
               b(l) = b(k)
               b(k) = t
   10       continue
            call saxpy(n-k,t,a(k+1,k),1,b(k+1),1)
   20    continue
   30    continue
c
cnow solve  u*x = y
c
         do 40 kb = 1, n
            k = n + 1 - kb
            b(k) = b(k)/a(k,k)
            t = -b(k)
            call saxpy(k-1,t,a(1,k),1,b(1),1)
   40    continue
      go to 100
   50 continue
c
cjob = nonzero, solve  trans(a) * x = b
cfirst solve  trans(u)*y = b
c
         do 60 k = 1, n
            t = sdot(k-1,a(1,k),1,b(1),1)
            b(k) = (b(k) - t)/a(k,k)
   60    continue
c
cnow solve trans(l)*x = y
c
         if (nm1 .lt. 1) go to 90
         do 80 kb = 1, nm1
            k = n - kb
            b(k) = b(k) + sdot(n-k,a(k+1,k),1,b(k+1),1)
            l = ipvt(k)
            if (l .eq. k) go to 70
               t = b(l)
               b(l) = b(k)
               b(k) = t
   70       continue
   80    continue
   90    continue
  100 continue
      return
      end
      subroutine sgbfa(abd,lda,n,ml,mu,ipvt,info)
clll. optimize
      integer lda,n,ml,mu,ipvt(n),info
      double precision abd(lda,n)
c
c sgbfa factors a double precision band matrix by elimination.
c
c sgbfa is usually called by sgbco, but it can be called
c directly with a saving in time if  rcond  is not needed.
c
c on entry
c
cabd     double precision(lda, n)
ccontains the matrix in band storage.  the columns
cof the matrix are stored in the columns of  abd  and
cthe diagonals of the matrix are stored in rows
cml+1 through 2*ml+mu+1 of  abd .
csee the comments below for details.
c
clda     integer
cthe leading dimension of the array  abd .
clda must be .ge. 2*ml + mu + 1 .
c
cn       integer
cthe order of the original matrix.
c
cml      integer
cnumber of diagonals below the main diagonal.
c0 .le. ml .lt. n .
c
cmu      integer
cnumber of diagonals above the main diagonal.
c0 .le. mu .lt. n .
cmore efficient if  ml .le. mu .
c on return
c
cabd     an upper triangular matrix in band storage and
cthe multipliers which were used to obtain it.
cthe factorization can be written  a = l*u  where
cl  is a product of permutation and unit lower
ctriangular matrices and  u  is upper triangular.
c
cipvt    integer(n)
can integer vector of pivot indices.
c
cinfo    integer
c= 0  normal value.
c= k  if  u(k,k) .eq. 0.0 .  this is not an error
c condition for this subroutine, but it does
c indicate that sgbsl will divide by zero if
c called.  use  rcond  in sgbco for a reliable
c indication of singularity.
c
c band storage
c
c   if  a  is a band matrix, the following program segment
c   will set up the input.
c
c   ml = (band width below the diagonal)
c   mu = (band width above the diagonal)
c   m = ml + mu + 1
c   do 20 j = 1, n
c  i1 = max0(1, j-mu)
c  i2 = min0(n, j+ml)
c  do 10 i = i1, i2
c k = i - j + m
c abd(k,j) = a(i,j)
c10    continue
c20 continue
c
c   this uses rows  ml+1  through  2*ml+mu+1  of  abd .
c   in addition, the first  ml  rows in  abd  are used for
c   elements generated during the triangularization.
c   the total number of rows needed in  abd  is  2*ml+mu+1 .
c   the  ml+mu by ml+mu  upper left triangle and the
c   ml by ml  lower right triangle are not referenced.
c
c linpack. this version dated 07/14/77 .
c cleve moler, university of new mexico, argonne national labs.
c
c subroutines and functions
c
c blas saxpy,sscal,isamax
c fortran max0,min0
c
c internal variables
c
      double precision t
      integer i,isamax,i0,j,ju,jz,j0,j1,k,kp1,l,lm,m,mm,nm1
c
c
      m = ml + mu + 1
      info = 0
c
c zero initial fill-in columns
c
      j0 = mu + 2
      j1 = min0(n,m) - 1
      if (j1 .lt. j0) go to 30
      do 20 jz = j0, j1
         i0 = m + 1 - jz
         do 10 i = i0, ml
            abd(i,jz) = 0.0d0
   10    continue
   20 continue
   30 continue
      jz = j1
      ju = 0
c
c gaussian elimination with partial pivoting
c
      nm1 = n - 1
      if (nm1 .lt. 1) go to 140
      do 130 k = 1, nm1
         kp1 = k + 1
c
czero next fill-in column
c
         jz = jz + 1
         if (jz .gt. n) go to 60
            if (ml .lt. 1) go to 50
            do 40 i = 1, ml
               abd(i,jz) = 0.0d0
   40       continue
   50       continue
   60    continue
c
cfind l = pivot index
c
         lm = min0(ml,n-k)
         l = isamax(lm+1,abd(m,k),1) + m - 1
         ipvt(k) = l + k - m
c
czero pivot implies this column already triangularized
c
         if (abd(l,k) .eq. 0.0d0) go to 110
c
c   interchange if necessary
c
            if (l .eq. m) go to 70
               t = abd(l,k)
               abd(l,k) = abd(m,k)
               abd(m,k) = t
   70       continue
c
c   compute multipliers
c
            t = -1.0d0/abd(m,k)
            call sscal(lm,t,abd(m+1,k),1)
c
c   row elimination with column indexing
c
            ju = min0(max0(ju,mu+ipvt(k)),n)
            mm = m
            if (ju .lt. kp1) go to 100
            do 90 j = kp1, ju
               l = l - 1
               mm = mm - 1
               t = abd(l,j)
               if (l .eq. mm) go to 80
                  abd(l,j) = abd(mm,j)
                  abd(mm,j) = t
   80          continue
               call saxpy(lm,t,abd(m+1,k),1,abd(mm+1,j),1)
   90       continue
  100       continue
         go to 120
  110    continue
            info = k
  120    continue
  130 continue
  140 continue
      ipvt(n) = n
      if (abd(m,n) .eq. 0.0d0) info = n
      return
      end
      subroutine sgbsl(abd,lda,n,ml,mu,ipvt,b,job)
clll. optimize
      integer lda,n,ml,mu,ipvt(n),job
      double precision abd(lda,n),b(n)
c
c sgbsl solves the double precision band system
c a * x = b  or  trans(a) * x = b
c using the factors computed by sgbco or sgbfa.
c
c on entry
c
cabd     double precision(lda, n)
cthe output from sgbco or sgbfa.
c
clda     integer
cthe leading dimension of the array  abd .
c
cn       integer
cthe order of the original matrix.
c
cml      integer
cnumber of diagonals below the main diagonal.
c
cmu      integer
cnumber of diagonals above the main diagonal.
c
cipvt    integer(n)
cthe pivot vector from sgbco or sgbfa.
c
cb       double precision(n)
cthe right hand side vector.
c
cjob     integer
c= 0         to solve  a*x = b ,
c= nonzero   to solve  trans(a)*x = b , where
ctrans(a)  is the transpose.
c
c on return
c
cb       the solution vector  x .
c
c error condition
c
ca division by zero will occur if the input factor contains a
czero on the diagonal.  technically this indicates singularity
cbut it is often caused by improper arguments or improper
csetting of lda .  it will not occur if the subroutines are
ccalled correctly and if sgbco has set rcond .gt. 0.0
cor sgbfa has set info .eq. 0 .
c
c to compute  inverse(a) * c  where  c  is a matrix
c with  p  columns
c   call sgbco(abd,lda,n,ml,mu,ipvt,rcond,z)
c   if (rcond is too small) go to ...
c   do 10 j = 1, p
c  call sgbsl(abd,lda,n,ml,mu,ipvt,c(1,j),0)
c10 continue
c
c linpack. this version dated 07/14/77 .
c cleve moler, university of new mexico, argonne national labs.
c
c subroutines and functions
c
c blas saxpy,sdot
c fortran min0
c
c internal variables
c
      double precision sdot,t
      integer k,kb,l,la,lb,lm,m,nm1
c
      m = mu + ml + 1
      nm1 = n - 1
      if (job .ne. 0) go to 60
c
cjob = 0 , solve  a * x = b
cfirst solve l*y = b
c
         if (ml .eq. 0) go to 40
            if (nm1 .lt. 1) go to 30
            do 20 k = 1, nm1
               lm = min0(ml,n-k)
               l = ipvt(k)
               t = b(l)
               if (l .eq. k) go to 10
                  b(l) = b(k)
                  b(k) = t
   10          continue
               call saxpy(lm,t,abd(m+1,k),1,b(k+1),1)
   20       continue
   30       continue
   40    continue
c
cnow solve  u*x = y
c
         do 50 kb = 1, n
            k = n + 1 - kb
            b(k) = b(k)/abd(m,k)
            lm = min0(k,m) - 1
            la = m - lm
            lb = k - lm
            t = -b(k)
            call saxpy(lm,t,abd(la,k),1,b(lb),1)
   50    continue
      go to 120
   60 continue
c
cjob = nonzero, solve  trans(a) * x = b
cfirst solve  trans(u)*y = b
c
         do 70 k = 1, n
            lm = min0(k,m) - 1
            la = m - lm
            lb = k - lm
            t = sdot(lm,abd(la,k),1,b(lb),1)
            b(k) = (b(k) - t)/abd(m,k)
   70    continue
c
cnow solve trans(l)*x = y
c
         if (ml .eq. 0) go to 110
            if (nm1 .lt. 1) go to 100
            do 90 kb = 1, nm1
               k = n - kb
               lm = min0(ml,n-k)
               b(k) = b(k) + sdot(lm,abd(m+1,k),1,b(k+1),1)
               l = ipvt(k)
               if (l .eq. k) go to 80
                  t = b(l)
                  b(l) = b(k)
                  b(k) = t
   80          continue
   90       continue
  100       continue
  110    continue
  120 continue
      return
      end
      subroutine saxpy(n,sa,sx,incx,sy,incy)
clll. optimize
c
c constant times a vector plus a vector.
c uses unrolled loop for increments equal to one.
c jack dongarra, linpack, 6/17/77.
c
      integer i,incx,incy,ix,iy,m,mp1,n
      double precision sx(*),sy(*),sa
cold  double precision sx(1),sy(1),sa
c
      if(n.le.0)return
      if (sa .eq. 0.0) return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
ccode for unequal increments or equal increments
c  not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        sy(iy) = sy(iy) + sa*sx(ix)
        ix = ix + incx
        iy = iy + incy
   10 continue
      return
c
ccode for both increments equal to 1
c
c
cclean-up loop
c
   20 m = mod(n,4)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        sy(i) = sy(i) + sa*sx(i)
   30 continue
      if( n .lt. 4 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,4
        sy(i) = sy(i) + sa*sx(i)
        sy(i + 1) = sy(i + 1) + sa*sx(i + 1)
        sy(i + 2) = sy(i + 2) + sa*sx(i + 2)
        sy(i + 3) = sy(i + 3) + sa*sx(i + 3)
   50 continue
      return
      end
      subroutine sscal(n,sa,sx,incx)
clll. optimize
c
c scales a vector by a constant.
c uses unrolled loops for increment equal to 1.
c jack dongarra, linpack, 6/17/77.
c
      integer i,incx,m,mp1,n,nincx
      double precision sa,sx(n)
c
      if(n.le.0)return
      if(incx.eq.1)go to 20
c
ccode for increment not equal to 1
c
      nincx = n*incx
      do 10 i = 1,nincx,incx
        sx(i) = sa*sx(i)
   10 continue
      return
c
ccode for increment equal to 1
c
c
cclean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        sx(i) = sa*sx(i)
   30 continue
      if( n .lt. 5 ) return
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        sx(i) = sa*sx(i)
        sx(i + 1) = sa*sx(i + 1)
        sx(i + 2) = sa*sx(i + 2)
        sx(i + 3) = sa*sx(i + 3)
        sx(i + 4) = sa*sx(i + 4)
   50 continue
      return
      end
      integer function isamax(n,sx,incx)
clll. optimize
c
c finds the index of element having max. absolute value.
c jack dongarra, linpack, 6/17/77.
c
      integer i,incx,ix,n
      double precision sx(n),smax
c
      isamax = 1
      if(n.le.1)return
      if(incx.eq.1)go to 20
c
ccode for increment not equal to 1
c
      ix = 1
      smax = abs(sx(1))
      ix = ix + incx
      do 10 i = 2,n
         if(abs(sx(ix)).le.smax) go to 5
         isamax = i
         smax = abs(sx(ix))
    5    ix = ix + incx
   10 continue
      return
c
ccode for increment equal to 1
c
   20 smax = abs(sx(1))
      do 30 i = 2,n
         if(abs(sx(i)).le.smax) go to 30
         isamax = i
         smax = abs(sx(i))
   30 continue
      return
      end
      double precision function sdot(n,sx,incx,sy,incy)
clll. optimize
c
c forms the dot product of a vector.
c uses unrolled loops for increments equal to one.
c jack dongarra, linpack, 6/17/77.
c
      integer i,incx,incy,ix,iy,m,mp1,n
      double precision sx(n),sy(n),stemp
c
      stemp = 0.0d0
      sdot = 0.0d0
      if(n.le.0)return
      if(incx.eq.1.and.incy.eq.1)go to 20
c
ccode for unequal increments or equal increments
c  not equal to 1
c
      ix = 1
      iy = 1
      if(incx.lt.0)ix = (-n+1)*incx + 1
      if(incy.lt.0)iy = (-n+1)*incy + 1
      do 10 i = 1,n
        stemp = stemp + sx(ix)*sy(iy)
        ix = ix + incx
        iy = iy + incy
   10 continue
      sdot = stemp
      return
c
ccode for both increments equal to 1
c
c
cclean-up loop
c
   20 m = mod(n,5)
      if( m .eq. 0 ) go to 40
      do 30 i = 1,m
        stemp = stemp + sx(i)*sy(i)
   30 continue
      if( n .lt. 5 ) go to 60
   40 mp1 = m + 1
      do 50 i = mp1,n,5
        stemp = stemp + sx(i)*sy(i) + sx(i + 1)*sy(i + 1) +
     *   sx(i + 2)*sy(i + 2) + sx(i + 3)*sy(i + 3) + sx(i + 4)*sy(i + 4)
   50 continue
   60 sdot = stemp
      return
      end
